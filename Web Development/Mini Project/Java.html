<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learn Java</title>
</head>
<body>
    <h1>Java - Basic Syntax</h1>
<hr />
<br>
<div class="clearer"></div>
<p>When we consider a Java program, it can be defined as a collection of objects that communicate via invoking each other's methods. Let us now briefly look into what do class, object, methods, and instance variables mean.</p>
<ul class="list">
<li><p><b>Object</b> &minus; Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behavior such as wagging their tail, barking, eating. An object is an instance of a class.</p></li>
<li><p><b>Class</b> &minus; A class can be defined as a template/blueprint that describes the behavior/state that the object of its type supports.</p></li>
<li><p><b>Methods</b> &minus; A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.</p></li>
<li><p><b>Instance Variables</b> &minus; Each object has its unique set of instance variables. An object's state is created by the values assigned to these instance variables.</p></li>
</ul>
<h2>First Java Program</h2>
<p>Let us look at a simple code that will print the words <b><i>Hello World</i></b>.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
public class MyFirstJavaProgram {

   /* This is my first java program.
    * This will print 'Hello World' as the output
    */

   public static void main(String []args) {
      System.out.println("Hello World"); // prints Hello World
   }
}
</pre>
<p>Let's look at how to save the file, compile, and run the program. Please follow the subsequent steps &minus;</p>
<ul class="list">
<li><p>Open notepad and add the code as above.</p></li>
<li><p>Save the file as: MyFirstJavaProgram.java.</p></li>
<li><p>Open a command prompt window and go to the directory where you saved the 	class. Assume it's C:\.</p></li>
<li><p>Type 'javac MyFirstJavaProgram.java' and press enter to compile your code. If there are no errors in your code, the command prompt will take you to the next line (Assumption : The path variable is set).</p></li>
<li><p>Now, type ' java MyFirstJavaProgram ' to run your program.</p></li>	
<li><p>You will be able to see ' Hello World ' printed on the window.</p></li>
</ul>
<h3>Output</h3>
<pre class="result notranslate">
C:\&gt; javac MyFirstJavaProgram.java
C:\&gt; java MyFirstJavaProgram 
Hello World
</pre>
<h2>Basic Syntax</h2>
<p>About Java programs, it is very important to keep in mind the following points.</p>
<ul class="list">
<li><p><b>Case Sensitivity</b> &minus; Java is case sensitive, which means identifier <b>Hello</b> and <b>hello</b> would have different meaning in Java.</p></li>
<li><p><b>Class Names</b> &minus; For all class names the first letter should be in Upper Case. If several words are used to form a name of the class, each inner word's first letter should be in Upper Case.</p>
<p><b>Example:</b> <i>class MyFirstJavaClass</i></p></li>
<li><p><b>Method Names</b> &minus; All method names should start with a Lower Case letter. If several words are  used to form the name of the method, then each inner word's first letter should be in Upper Case.</p>
<p><b>Example:</b> <i>public void myMethodName()</i></p></li>
<li><p><b>Program File Name</b> &minus; Name of the program file should exactly match the class name.</p>
<p>When saving the file, you should save it using the class name (Remember Java is case sensitive) and append '.java' to the end of the name (if the file name and the class name do not match, your program will not compile).</p>
<p>But please make a note that in case  you do not have a public class present in the file then file name can be different than class name.  It is also not mandatory to have a public class in the file.</p>
<p><b>Example:</b> Assume 'MyFirstJavaProgram' is the class name. Then the file should be saved as <i>'MyFirstJavaProgram.java'</i></p></li>
<li><p><b>public static void main(String args[])</b> &minus; Java program processing starts from the main() method which is a mandatory part of every Java program.</p></li>
</ul>
<h2>Java Identifiers</h2>
<p>All Java components require names. Names used for classes, variables, and methods are called <b>identifiers</b>.</p>
<p>In Java, there are several points to remember about identifiers. They are as follows &minus;</p>
<ul class="list">
<li><p>All identifiers should begin with a letter (A to Z or a to z), currency character ($) or an underscore (_).</p></li>
<li><p>After the first character, identifiers can have any combination of characters.</p></li>
<li><p>A key word cannot be used as an identifier.</p></li>
<li><p>Most importantly, identifiers are case sensitive.</p></li>
<li><p>Examples of legal identifiers: age, $salary, _value, __1_value.</p></li>
<li><p>Examples of illegal identifiers: 123abc, -salary.</p></li>
</ul>
<h2>Java Modifiers</h2>
<p>Like other languages, it is possible to modify classes, methods, etc., by using modifiers. There are two categories of modifiers &minus;</p>
<ul class="list">
<li><p><b>Access Modifiers</b> &minus; default, public , protected, private</p></li>
<li><p><b>Non-access Modifiers</b> &minus; final, abstract, strictfp</p></li>
</ul>
<p>We will be looking into more details about modifiers in the next section.</p>
<h2>Java Variables</h2>
<p>Following are the types of variables in Java &minus;</p>
<ul class="list">
<li>Local Variables</li>
<li>Class Variables (Static Variables)</li>
<li>Instance Variables (Non-static Variables)</li>
</ul>
<h2>Java Arrays</h2>
<p>Arrays are objects that store multiple variables of the same type. However, an array itself is an object on the heap. We will look into how to declare, construct, and initialize in the upcoming chapters.</p>
<h2>Java Enums</h2>
<p>Enums were introduced in Java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.</p>
<p>With the use of enums it is possible to reduce the number of bugs in your code.</p>
<p>For example, if we consider an application for a fresh juice shop, it would be possible to restrict the glass size to small, medium, and large. This would make sure that it would not allow anyone to order any size other than small, medium, or large.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
class FreshJuice {
   enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }
   FreshJuiceSize size;
}

public class FreshJuiceTest {

   public static void main(String args[]) {
      FreshJuice juice = new FreshJuice();
      juice.size = FreshJuice.FreshJuiceSize.MEDIUM ;
      System.out.println("Size: " + juice.size);
   }
}
</pre>
<p>The above example will produce the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Size: MEDIUM
</pre>
<p><b>Note</b> &minus; Enums can be declared as their own or inside a class. Methods, variables, constructors can be defined inside enums as well.</p>
<h2>Java Keywords</h2>
<p>The following list shows the reserved words in Java. These reserved words may not be used as constant or variable or any other identifier names.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<td>abstract</td>
<td>assert</td>
<td>boolean</td>
<td>break</td>
</tr>
<tr>
<td>byte</td>
<td>case</td>
<td>catch</td>
<td>char</td>
</tr>
<tr>
<td>class</td>
<td>const</td>
<td>continue</td>
<td>default</td>
</tr>
<tr>
<td>do</td>
<td>double</td>
<td>else</td>
<td>enum</td>
</tr>
<tr>
<td>extends</td>
<td>final</td>
<td>finally</td>
<td>float</td>
</tr>
<tr>
<td>for</td>
<td>goto</td>
<td>if</td>
<td>implements</td>
</tr>
<tr>
<td>import</td>
<td>instanceof</td>
<td>int</td>
<td>interface</td>
</tr>
<tr>
<td>long</td>
<td>native</td>
<td>new</td>
<td>package</td>
</tr>
<tr>
<td>private</td>
<td>protected</td>
<td>public</td>
<td>return</td>
</tr>
<tr>
<td>short</td>
<td>static</td>
<td>strictfp</td>
<td>super</td>
</tr>
<tr>
<td>switch</td>
<td>synchronized</td>
<td>this</td>
<td>throw</td>
</tr>
<tr>
<td>throws</td>
<td>transient</td>
<td>try</td>
<td>void</td>
</tr>
<tr>
<td>volatile</td>
<td>while</td>
<td></td>
<td></td>
</tr>
</table>
<h2>Comments in Java</h2>
<p>Java supports single-line and multi-line comments very similar to C and C&plus;&plus;. All characters available inside any comment are ignored by Java compiler.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
public class MyFirstJavaProgram {

   /* This is my first java program.
    * This will print 'Hello World' as the output
    * This is an example of multi-line comments.
    */

   public static void main(String []args) {
      // This is an example of single line comment
      /* This is also an example of single line comment. */
      System.out.println("Hello World");
   }
}
</pre>
<h3>Output</h3>
<pre class="result notranslate">
Hello World
</pre>
<h2>Using Blank Lines</h2>
<p>A line containing only white space, possibly with a comment, is known as a blank line, and Java totally ignores it.</p>
<h2>Inheritance</h2>
<p>In Java, classes can be derived from classes. Basically, if you need to create a new class and here is already a class that has some of the code you require, then it is possible to derive your new class from the already existing code.</p>
<p>This concept allows you to reuse the fields and methods of the existing class without having to rewrite the code in a new class. In this scenario, the existing class is called the <b>superclass</b> and the derived class is called the <b>subclass</b>.</p>
<h2>Interfaces</h2>
<p>In Java language, an interface can be defined as a contract between objects on how to communicate with each other. Interfaces play a vital role when it comes to the concept of inheritance.</p>
<p>An interface defines the methods, a deriving class (subclass) should use. But the implementation of the methods is totally up to the subclass.</p>
<h1>Java - Object and Classes</h1>
<hr />
<br>
<div class="clearer"></div>
<p>Java is an Object-Oriented Language. As a language that has the Object-Oriented feature, Java supports the following fundamental concepts &minus;</p>
<ul class="list">
<li>Polymorphism</li>
<li>Inheritance</li>
<li>Encapsulation</li>
<li>Abstraction</li>
<li>Classes</li>
<li>Objects</li>
<li>Instance</li>
<li>Method</li>
<li>Message Passing</li>
</ul>
<p>In this chapter, we will look into the concepts - Classes and Objects.</p>
<ul class="list">
<li><p><b>Object</b> &minus; Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors â€“ wagging the tail, barking, eating. An object is an instance of a class.</p></li>
<li><p><b>Class</b> &minus; A class can be defined as a template/blueprint that describes the behavior/state that the object of its type support.</p></li>
</ul>
<h2>Objects in Java</h2>
<p>Let us now look deep into what are objects. If we consider the real-world, we can find many objects around us, cars, dogs, humans, etc. All these objects have a state and a behavior.</p>
<p>If we consider a dog, then its state is - name, breed, color, and the behavior is - barking, wagging the tail, running.</p>
<p>If you compare the software object with a real-world object, they have very similar characteristics.</p>
<p>Software objects also have a state and a behavior. A software object's state is stored in fields and behavior is shown via methods.</p>
<p>So in software development, methods operate on the internal state of an object and the object-to-object communication is done via methods.</p>
<h2>Classes in Java</h2>
<p>A class is a blueprint from which individual objects are created.</p>
<p>Following is a sample of a class.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
public class Dog {
   String breed;
   int age;
   String color;

   void barking() {
   }

   void hungry() {
   }

   void sleeping() {
   }
}
</pre>
<p>A class can contain any of the following variable types.</p>
<ul class="list">
<li><p><b>Local variables</b> &minus; Variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.</p></li>
<li><p><b>Instance variables</b> &minus; Instance variables are variables within a class but outside any method. These variables are initialized when the class is instantiated. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.</p></li>
<li><p><b>Class variables</b> &minus; Class variables are variables declared within a class, outside any method, with the static keyword.</p></li>
</ul>
<p>A class can have any number of methods to access the value of various kinds of methods. In the above example, barking(), hungry() and sleeping() are methods.</p>
<p>Following are some of the important topics that need to be discussed when looking into classes of the Java Language.</p>
<h2>Constructors</h2>
<p>When discussing about classes, one of the most important sub topic would be constructors. Every class has a constructor. If we do not explicitly write a constructor for a class, the Java compiler builds a default constructor for that class.</p>
<p>Each time a new object is created, at least one constructor will be invoked. The main rule of constructors is that they should have the same name as the class. A class can have more than one constructor.</p>
<p>Following is an example of a constructor &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
public class Puppy {
   public Puppy() {
   }

   public Puppy(String name) {
      // This constructor has one parameter, <i>name</i>.
   }
}
</pre>
<p>Java also supports <p>Singleton Classes</p> where you would be able to create only one instance of a class.</p>
<p><b>Note</b> &minus; We have two different types of constructors. We are going to discuss constructors in detail in the subsequent chapters.</p>
<h2>Creating an Object</h2>
<p>As mentioned previously, a class provides the blueprints for objects. So basically, an object is created from a class. In Java, the new keyword is used to create new objects.</p>
<p>There are three steps when creating an object from a class &minus;</p>
<ul class="list">
<li><p><b>Declaration</b> &minus; A variable declaration with a variable name with an object type.</p></li>
<li><p><b>Instantiation</b> &minus; The 'new' keyword is used to create the object.</p></li>
<li><p><b>Initialization</b> &minus; The 'new' keyword is followed by a call to a constructor. This call initializes the new object.</p></li>
</ul>
<p>Following is an example of creating an object &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
public class Puppy {
   public Puppy(String name) {
      // This constructor has one parameter, <i>name</i>.
      System.out.println("Passed Name is :" + name );
   }

   public static void main(String []args) {
      // Following statement would create an object myPuppy
      Puppy myPuppy = new Puppy( "tommy" );
   }
}
</pre>
<p>If we compile and run the above program, then it will produce the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Passed Name is :tommy
</pre>
<h2>Accessing Instance Variables and Methods</h2>
<p>Instance variables and methods are accessed via created objects. To access an instance variable, following is the fully qualified path &minus;</p>
<pre class="result notranslate">
/* First create an object */
ObjectReference = new Constructor();

/* Now call a variable as follows */
ObjectReference.variableName;

/* Now you can call a class method as follows */
ObjectReference.MethodName();
</pre>
<h3>Example</h3>
<p>This example explains how to access instance variables and methods of a class.</p>
<pre class="prettyprint notranslate">
public class Puppy {
   int puppyAge;

   public Puppy(String name) {
      // This constructor has one parameter, <i>name</i>.
      System.out.println("Name chosen is :" + name );
   }

   public void setAge( int age ) {
      puppyAge = age;
   }

   public int getAge( ) {
      System.out.println("Puppy's age is :" + puppyAge );
      return puppyAge;
   }

   public static void main(String []args) {
      /* Object creation */
      Puppy myPuppy = new Puppy( "tommy" );

      /* Call class method to set puppy's age */
      myPuppy.setAge( 2 );

      /* Call another class method to get puppy's age */
      myPuppy.getAge( );

      /* You can access instance variable as follows as well */
      System.out.println("Variable Value :" + myPuppy.puppyAge );
   }
}
</pre>
<p>If we compile and run the above program, then it will produce the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Name chosen is :tommy
Puppy's age is :2
Variable Value :2
</pre>
<h2>Source File Declaration Rules</h2>
<p>As the last part of this section, let's now look into the source file declaration rules. These rules are essential when declaring classes, <i>import</i> statements and <i>package</i> statements in a source file.</p>
<ul class="list">
<li><p>There can be only one public class per source file.</p></li>
<li><p>A source file can have multiple non-public classes.</p></li>
<li><p>The public class name should be the name of the source file as well which should be appended by <b>.java</b> at the end. For example: the class name is <i>public class Employee{}</i> then the source file should be as Employee.java.</p></li>
<li><p>If the class is defined inside a package, then the package statement should be the first statement in the source file.</p></li>
<li><p>If import statements are present, then they must be written between the package statement and the class declaration. If there are no package statements, then the import statement should be the first line in the source file.</p></li>
<li><p>Import and package statements will imply to all the classes present in the source file. It is not possible to declare different import and/or package statements to different classes in the source file.</p></li>
</ul>
<p>Classes have several access levels and there are different types of classes; abstract classes, final classes, etc. We will be explaining about all these in the access modifiers chapter.</p>
<p>Apart from the above mentioned types of classes, Java also has some special classes called Inner classes and Anonymous classes.</p>
<h2>Java Package</h2>
<p>In simple words, it is a way of categorizing the classes and interfaces. When developing applications in Java, hundreds of classes and interfaces will be written, therefore categorizing these classes is a must as well as makes life much easier.</p>
<h2>Import Statements</h2>
<p>In Java if a fully qualified name, which includes the package and the class name is given, then the compiler can easily locate the source code or classes. Import statement is a way of giving the proper location for the compiler to find that particular class.</p>
<p>For example, the following line would ask the compiler to load all the classes available in directory java_installation/java/io &minus;</p>
<pre class="result notranslate">
import java.io.*;
</pre>
<h2>A Simple Case Study</h2>
<p>For our case study, we will be creating two classes. They are Employee and EmployeeTest.</p>
<p>First open notepad and add the following code. Remember this is the Employee class and the class is a public class. Now, save this source file with the name Employee.java.</p>
<p>The Employee class has four instance variables - name, age, designation and salary. The class has one explicitly defined constructor, which takes a parameter.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
import java.io.*;
public class Employee {

   String name;
   int age;
   String designation;
   double salary;

   // This is the constructor of the class Employee
   public Employee(String name) {
      this.name = name;
   }

   // Assign the age of the Employee  to the variable age.
   public void empAge(int empAge) {
      age = empAge;
   }

   /* Assign the designation to the variable designation.*/
   public void empDesignation(String empDesig) {
      designation = empDesig;
   }

   /* Assign the salary to the variable	salary.*/
   public void empSalary(double empSalary) {
      salary = empSalary;
   }

   /* Print the Employee details */
   public void printEmployee() {
      System.out.println("Name:"+ name );
      System.out.println("Age:" + age );
      System.out.println("Designation:" + designation );
      System.out.println("Salary:" + salary);
   }
}
</pre>
<p>As mentioned previously in this tutorial, processing starts from the main method. Therefore, in order for us to run this Employee class there should be a main method and objects should be created. We will be creating a separate class for these tasks.</p>
<p>Following is the <i>EmployeeTest</i> class, which creates two instances of the class Employee and invokes the methods for each object to assign values for each variable.</p>
<p>Save the following code in EmployeeTest.java file.</p>
<pre class="prettyprint notranslate">
import java.io.*;
public class EmployeeTest {

   public static void main(String args[]) {
      /* Create two objects using constructor */
      Employee empOne = new Employee("James Smith");
      Employee empTwo = new Employee("Mary Anne");

      // Invoking methods for each object created
      empOne.empAge(26);
      empOne.empDesignation("Senior Software Engineer");
      empOne.empSalary(1000);
      empOne.printEmployee();

      empTwo.empAge(21);
      empTwo.empDesignation("Software Engineer");
      empTwo.empSalary(500);
      empTwo.printEmployee();
   }
}
</pre>
<p>Now, compile both the classes and then run <i>EmployeeTest</i> to see the result as follows &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
C:\&gt; javac Employee.java
C:\&gt; javac EmployeeTest.java
C:\&gt; java EmployeeTest
Name:James Smith
Age:26
Designation:Senior Software Engineer
Salary:1000.0
Name:Mary Anne
Age:21
Designation:Software Engineer
Salary:500.0
</pre>
<h1>Java - Basic Datatypes</h1>
<hr />
<br>
<div class="clearer"></div>
<p>Variables are nothing but reserved memory locations to store values. This means that when you create a variable you reserve some space in the memory.</p>
<p>Based on the data type of a variable, the operating system allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables.</p>
<p>There are two data types available in Java &minus;</p>
<ul class="list">
<li>Primitive Data Types</li>
<li>Reference/Object Data Types</li>
</ul>
<h2>Primitive Data Types</h2>
<p>There are eight primitive datatypes supported by Java. Primitive datatypes are predefined by the language and named by a keyword. Let us now look into the eight primitive data types in detail.</p>
<h3>byte</h3>
<ul class="list">
<li><p>Byte data type is an 8-bit signed two's complement integer</p></li>
<li><p>Minimum value is -128 (-2&#94;7)</p></li>
<li><p>Maximum value is 127 (inclusive)(2&#94;7 -1)</p></li>
<li><p>Default value is 0</p></li>
<li><p>Byte data type is used to save space in large arrays, mainly in place of integers, since a byte is four times smaller than an integer.</p></li>
<li><p>Example: byte a = 100, byte b = -50</p></li>
</ul>
<h3>short</h3>
<ul class="list">
<li><p>Short data type is a 16-bit signed two's complement integer</p></li>
<li><p>Minimum value is -32,768 (-2&#94;15)</p></li>
<li><p>Maximum value is 32,767 (inclusive) (2&#94;15 -1)</p></li>
<li><p>Short data type can also be used to save memory as byte data type. A short is 2 times smaller than an integer</p></li>
<li><p>Default value is 0.</p></li>
<li><p>Example: short  s = 10000, short r = -20000</p></li>
</ul>
<h3>int</h3>
<ul class="list">
<li><p>Int data type is a 32-bit signed two's complement integer.</p></li>
<li><p>Minimum value is - 2,147,483,648 (-2&#94;31)</p></li>
<li><p>Maximum value is 2,147,483,647(inclusive) (2&#94;31 -1)</p></li>
<li><p>Integer is generally used as the default data type for integral values unless there is a concern about memory.</p></li>
<li><p>The default value is 0</p></li>
<li><p>Example: int a = 100000, int b = -200000</p></li>
</ul>
<h3>long</h3>
<ul class="list">
<li>Long data type is a 64-bit signed two's complement integer</li>
<li>Minimum value is -9,223,372,036,854,775,808(-2&#94;63)</li>
<li>Maximum value is 9,223,372,036,854,775,807 (inclusive)(2&#94;63 -1)</li>
<li>This type is used when a wider range than int is needed</li>
<li>Default value is 0L</li>
<li>Example: long a = 100000L, long b = -200000L</li>
</ul>
<h3>float</h3>
<ul class="list">
<li><p>Float data type is a single-precision 32-bit IEEE 754 floating point</p></li>
<li><p>Float is mainly used to save memory in large arrays of floating point numbers</p></li>
<li><p>Default value is 0.0f</p></li>
<li><p>Float data type is never used for precise values such as currency</p></li>
<li><p>Example: float f1 = 234.5f</p></li>
</ul>
<h3>double</h3>
<ul class="list">
<li><p>double data type is a double-precision 64-bit IEEE 754 floating point</p></li> 
<li><p>This data type is generally used as the default data type for decimal values, generally the default choice</p></li>
<li><p>Double data type should never be used for precise values such as currency</p></li>
<li><p>Default value is 0.0d</p></li>
<li><p>Example: double d1 = 123.4</p></li>
</ul>
<h3>boolean</h3>
<ul class="list">
<li>boolean data type represents one bit of information</li>
<li>There are only two possible values: true and false</li>
<li>This data type is used for simple flags that track true/false conditions</li>
<li>Default value is false</li>
<li>Example: boolean one = true</li>
</ul>
<h3>char</h3>
<ul class="list">
<li>char data type is a single 16-bit Unicode character</li>
<li>Minimum value is '\u0000' (or 0)</li>
<li>Maximum value is  '\uffff' (or 65,535 inclusive)</li>
<li>Char data type is used to store any character</li> 
<li>Example: char letterA = 'A'</li>
</ul>
<h2>Reference Datatypes</h2>
<ul class="list">
<li><p>Reference variables are created using defined constructors of the classes. They are used to access objects. These variables are declared to be of a specific type that cannot be changed. For example, Employee, Puppy, etc.</p></li> 
<li><p>Class objects and various type of array variables come under reference datatype.</p></li>
<li><p>Default value of any reference variable is null.</p></li> 
<li><p>A reference variable can be used to refer any object of the declared type or any compatible type.</p></li> 
<li><p>Example: Animal animal = new Animal("giraffe");</p></li> 
</ul>
<h2>Java Literals</h2>
<p>A literal is a source code representation of a fixed value. They are represented directly in the code without any computation.</p>
<p>Literals can be assigned to any primitive type variable. For example &minus;</p>
<pre class="prettyprint notranslate">
byte a = 68;
char a = 'A';
</pre>
<p>byte, int, long, and short can be expressed in decimal(base 10), hexadecimal(base 16) or octal(base 8) number systems as well.</p>
<p>Prefix 0 is used to indicate octal, and prefix 0x indicates hexadecimal when using these number systems for literals. For example &minus;</p>
<pre class="prettyprint notranslate">
int decimal = 100;
int octal = 0144;
int hexa =  0x64;
</pre>
<p>String literals in Java are specified like they are in most other languages by enclosing a sequence of characters between a pair of double quotes. Examples of string literals are &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
"Hello World"
"two\nlines"
"\"This is in quotes\""
</pre>
<p>String and char types of literals can contain any Unicode characters. For example &minus;</p>
<pre class="prettyprint notranslate">
char a = '\u0001';
String a = "\u0001";
</pre>
<p>Java language supports few special escape sequences for String and char literals as well. They are &minus;</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Notation</th>
<th style="text-align:center;">Character represented</th>
</tr>
<tr>
<td>\n</td>
<td>Newline (0x0a)</td>
</tr>
<tr>
<td>\r</td>
<td>Carriage return (0x0d)</td>
</tr>
<tr>
<td>\f</td>
<td>Formfeed (0x0c)</td>
</tr>
<tr>
<td>\b</td>
<td>Backspace (0x08)</td>
</tr>
<tr>
<td>\s</td>
<td>Space (0x20)</td>
</tr>
<tr>
<td>\t</td>
<td>tab</td>
</tr>
<tr>
<td>\" </td>
<td>Double quote</td>
</tr>
<tr>
<td>\'</td>
<td>Single quote</td>
</tr>
<tr>
<td>\\</td>
<td>backslash</td>
</tr>
<tr>
<td>\ddd</td>
<td>Octal character (ddd)</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>Hexadecimal UNICODE character (xxxx)</td>
</tr>
</table>
<h1>Java - Exceptions</h1>
<hr />
<br>
<div class="clearer"></div>
<p>An exception (or exceptional event) is a problem that arises during the execution of a program. When an <b>Exception</b> occurs the normal flow of the program is disrupted and the program/Application terminates abnormally, which is not recommended, therefore, these exceptions are to be handled.</p>
<p>An exception can occur for many different reasons. Following are some scenarios where an exception occurs.</p>
<ul class="list">
<li><p>A user has entered an invalid data.</p></li>
<li><p>A file that needs to be opened cannot be found.</p></li>
<li><p>A network connection has been lost in the middle of communications or the JVM has run out of memory.</p></li>
</ul>
<p>Some of these exceptions are caused by user error, others by programmer error, and others by physical resources that have failed in some manner.</p>
<p>Based on these, we have three categories of Exceptions. You need to understand them to know how exception handling works in Java.</p>
<ul class="list">
<li><p><b>Checked exceptions</b> &minus; A checked exception is an exception that is checked (notified) by the compiler at compilation-time, these are also called as compile time exceptions. These exceptions cannot simply be ignored, the programmer should take care of (handle) these exceptions.</p></li>
</ul>
<p>For example, if you use <b>FileReader</b> class in your program to read data from a file, if the file specified in its constructor doesn't exist, then a <i>FileNotFoundException</i> occurs, and the compiler prompts the programmer to handle the exception.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
import java.io.File;
import java.io.FileReader;

public class FilenotFound_Demo {

   public static void main(String args[]) {		
      File file = new File("E://file.txt");
      FileReader fr = new FileReader(file); 
   }
}
</pre>
<p>If you try to compile the above program, you will get the following exceptions.</p>
<h3>Output</h3>
<pre class="result notranslate">
C:\&gt;javac FilenotFound_Demo.java
FilenotFound_Demo.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown
      FileReader fr = new FileReader(file);
                      ^
1 error
</pre>
<p><b>Note</b> &minus; Since the methods <b>read()</b> and <b>close()</b> of FileReader class throws IOException, you can observe that the compiler notifies to handle IOException, along with FileNotFoundException.</p>
<ul class="list">
<li><p><b>Unchecked exceptions</b> &minus; An unchecked exception is an exception that occurs at the time of execution. These are also called as <b>Runtime Exceptions</b>. These include programming bugs, such as logic errors or improper use of an API. Runtime exceptions are ignored at the time of compilation.</p></li>
</ul>
<p>For example, if you have declared an array of size 5 in your program, and trying to call the 6<sup>th</sup> element of the array then an <i>ArrayIndexOutOfBoundsExceptionexception</i> occurs.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
public class Unchecked_Demo {
   
   public static void main(String args[]) {
      int num[] = {1, 2, 3, 4};
      System.out.println(num[5]);
   }
}
</pre>
<p>If you compile and execute the above program, you will get the following exception.</p>
<h3>Output</h3>
<pre class="result notranslate">
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5
	at Exceptions.Unchecked_Demo.main(Unchecked_Demo.java:8)
</pre>
<ul class="list">
<li><p><b>Errors</b> &minus; These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. For example, if a stack overflow occurs, an error will arise. They are also ignored at the time of compilation.</p></li>
</ul>
<h2>Exception Hierarchy</h2>
<p>All exception classes are subtypes of the java.lang.Exception class. The exception class is a subclass of the Throwable class. Other than the exception class there is another subclass called Error which is derived from the Throwable class.</p>
<p>Errors are abnormal conditions that happen in case of severe failures, these are not handled by the Java programs. Errors are generated to indicate errors generated by the runtime environment. Example: JVM is out of memory. Normally, programs cannot recover from errors.</p>
<p>The Exception class has two main subclasses: IOException class and RuntimeException Class.</p>
<img src="/java/images/exceptions1.jpg" alt="Exceptions1" />
<p>Following is a list of most common checked and unchecked <a href="/java/java_builtin_exceptions.htm">Java's Built-in Exceptions</a>.</p>
<h2>Exceptions Methods</h2>
<p>Following is the list of important methods available in the Throwable class.</p>
<table class="table table-bordered">
<tr>
<th>Sr.No.</th>
<th style="text-align:center;">Method &amp; Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td><p><b>public String getMessage()</b></p>
<p>Returns a detailed message about the exception that has occurred. This message is initialized in the Throwable constructor.</p>
</td>
</tr>
<tr>
<td class="ts">2</td>
<td><p><b>public Throwable getCause()</b></p>
<p>Returns the cause of the exception as represented by a Throwable object.</p>
</td>
</tr>
<tr>
<td class="ts">3</td>
<td><p><b>public String toString()</b></p>
<p>Returns the name of the class concatenated with the result of getMessage().</p>
</td>
</tr>
<tr>
<td class="ts">4</td>
<td><p><b>public void printStackTrace()</b></p>
<p>Prints the result of toString() along with the stack trace to System.err, the error output stream.</p>
</td>
</tr>
<tr>
<td class="ts">5</td>
<td><p><b>public StackTraceElement [] getStackTrace()</b></p>
<p>Returns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack, and the last element in the array represents the method at the bottom of the call stack.</p>
</td>
</tr>
<tr>
<td class="ts">6</td>
<td><p><b>public Throwable fillInStackTrace()</b></p>
<p>Fills the stack trace of this Throwable object with the current stack trace, adding to any previous information in the stack trace.</p>
</td>
</tr>
</table>
<h2>Catching Exceptions</h2>
<p>A method catches an exception using a combination of the <b>try</b> and <b>catch</b> keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
try {
   // Protected code
} catch (ExceptionName e1) {
   // Catch block
}
</pre>
<p>The code which is prone to exceptions is placed in the try block. When an exception occurs, that exception occurred is handled by catch block associated with it. Every try block should be immediately followed either by a catch block or finally block.</p>
<p>A catch statement involves declaring the type of exception you are trying to catch. If an exception occurs in protected code, the catch block (or blocks) that follows the try is checked. If the type of exception that occurred is listed in a catch block, the exception is passed to the catch block much as an argument is passed into a method parameter.</p>
<h3>Example</h3>
<p>The following is an array declared with 2 elements. Then the code tries to access the 3<sup>rd</sup> element of the array which throws an exception.</p>
<pre class="prettyprint notranslate">
// File Name : ExcepTest.java
import java.io.*;

public class ExcepTest {

   public static void main(String args[]) {
      try {
         int a[] = new int[2];
         System.out.println("Access element three :" + a[3]);
      } catch (ArrayIndexOutOfBoundsException e) {
         System.out.println("Exception thrown  :" + e);
      }
      System.out.println("Out of the block");
   }
}
</pre>
<p>This will produce the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3
Out of the block
</pre>
<h2>Multiple Catch Blocks</h2>
<p>A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
try {
   // Protected code
} catch (ExceptionType1 e1) {
   // Catch block
} catch (ExceptionType2 e2) {
   // Catch block
} catch (ExceptionType3 e3) {
   // Catch block
}
</pre>
<p>The previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.</p>
<h3>Example</h3>
<p>Here is code segment showing how to use multiple try/catch statements.</p>
<pre class="prettyprint notranslate">
try {
   file = new FileInputStream(fileName);
   x = (byte) file.read();
} catch (IOException i) {
   i.printStackTrace();
   return -1;
} catch (FileNotFoundException f) // Not valid! {
   f.printStackTrace();
   return -1;
}
</pre>
<h2>Catching Multiple Type of Exceptions</h2>
<p>Since Java 7, you can handle more than one exception using a single catch block, this feature simplifies the code. Here is how you would do it &minus;</p>
<pre class="result notranslate">
catch (IOException|FileNotFoundException ex) {
   logger.log(ex);
   throw ex;
</pre>
<h2>The Throws/Throw Keywords</h2>
<p>If a method does not handle a checked exception, the method must declare it using the <b>throws</b> keyword. The throws keyword appears at the end of a method's signature.</p>
<p>You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the <b>throw</b> keyword.</p>
<p>Try to understand the difference between throws and throw keywords, <i>throws</i> is used to postpone the handling of a checked exception and <i>throw</i> is used to invoke an exception explicitly.</p>
<p>The following method declares that it throws a RemoteException &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
import java.io.*;
public class className {

   public void deposit(double amount) throws RemoteException {
      // Method implementation
      throw new RemoteException();
   }
   // Remainder of class definition
}
</pre>
<p>A method can declare that it throws more than one exception, in which case the exceptions are declared in a list separated by commas. For example, the following method declares that it throws a RemoteException and an InsufficientFundsException &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
import java.io.*;
public class className {

   public void withdraw(double amount) throws RemoteException, 
      InsufficientFundsException {
      // Method implementation
   }
   // Remainder of class definition
}
</pre>
<h2>The Finally Block</h2>
<p>The finally block follows a try block or a catch block. A finally block of code always executes, irrespective of occurrence of an Exception.</p>
<p>Using a finally block allows you to run any cleanup-type statements that you want to execute, no matter what happens in the protected code.</p>
<p>A finally block appears at the end of the catch blocks and has the following syntax &minus;</p>
<h3>Syntax</h3>
<pre class="result notranslate">
try {
   // Protected code
} catch (ExceptionType1 e1) {
   // Catch block
} catch (ExceptionType2 e2) {
   // Catch block
} catch (ExceptionType3 e3) {
   // Catch block
}finally {
   // The finally block always executes.
}
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate">
public class ExcepTest {

   public static void main(String args[]) {
      int a[] = new int[2];
      try {
         System.out.println("Access element three :" + a[3]);
      } catch (ArrayIndexOutOfBoundsException e) {
         System.out.println("Exception thrown  :" + e);
      }finally {
         a[0] = 6;
         System.out.println("First element value: " + a[0]);
         System.out.println("The finally statement is executed");
      }
   }
}
</pre>
<p>This will produce the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3
First element value: 6
The finally statement is executed
</pre>
<p>Note the following &minus;</p>
<ul class="list">
<li><p>A catch clause cannot exist without a try statement.</p></li>
<li><p>It is not compulsory to have finally clauses whenever a try/catch block is present.</p></li>
<li><p>The try block cannot be present without either catch clause or finally clause.</p></li>
<li><p>Any code cannot be present in between the try, catch, finally blocks.</p></li>
</ul>
<h2>The try-with-resources</h2>
<p>Generally, when we use any resources like streams, connections, etc. we have to close them explicitly using finally block. In the following program, we are reading data from a file using <b>FileReader</b> and we are closing it using finally block.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate">
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class ReadData_Demo {

   public static void main(String args[]) {
      FileReader fr = null;		
      try {
         File file = new File("file.txt");
         fr = new FileReader(file); char [] a = new char[50];
         fr.read(a);   // reads the content to the array
         for(char c : a)
         System.out.print(c);   // prints the characters one by one
      } catch (IOException e) {
         e.printStackTrace();
      }finally {
         try {
            fr.close();
         } catch (IOException ex) {		
            ex.printStackTrace();
         }
      }
   }
}
</pre>
<p><b>try-with-resources</b>, also referred as <b>automatic resource management</b>, is a new exception handling mechanism that was introduced in Java 7, which automatically closes the resources used within the try catch block.</p>
<p>To use this statement, you simply need to declare the required resources within the parenthesis, and the created resource will be closed automatically at the end of the block. Following is the syntax of try-with-resources statement.</p>
<h3>Syntax</h3>
<pre class ="result notranslate">
try(FileReader fr = new FileReader("file path")) {
   // use the resource
   } catch () {
      // body of catch 
   }
}
</pre>
<p>Following is the program that reads the data in a file using try-with-resources statement.</p>
<h3>Example</h3>
<pre class ="prettyprint notranslate">
import java.io.FileReader;
import java.io.IOException;

public class Try_withDemo {

   public static void main(String args[]) {
      try(FileReader fr = new FileReader("E://file.txt")) {
         char [] a = new char[50];
         fr.read(a);   // reads the contentto the array
         for(char c : a)
         System.out.print(c);   // prints the characters one by one
      } catch (IOException e) {
         e.printStackTrace();
      }
   }
}
</pre>
<p>Following points are to be kept in mind while working with try-with-resources statement.</p>
<ul class="list">
<li><p>To use a class with try-with-resources statement it should implement <b>AutoCloseable</b> interface and the <b>close()</b> method of it gets invoked automatically at runtime.</p></li>
<li><p>You can declare more than one class in try-with-resources statement.</p></li>
<li><p>While you declare multiple classes in the try block of try-with-resources statement these classes are closed in reverse order.</p></li>
<li><p>Except the declaration of resources within the parenthesis everything is the same as normal try/catch block of a try block.</p></li>
<li><p>The resource declared in try gets instantiated just before the start of the try-block.</p></li>
<li><p>The resource declared at the try block is implicitly declared as final.</p></li>
</ul>
<h2>User-defined Exceptions</h2>
<p>You can create your own exceptions in Java. Keep the following points in mind when writing your own exception classes &minus;</p>
<ul class="list">
<li><p>All exceptions must be a child of Throwable.</p></li>
<li><p>If you want to write a checked exception that is automatically enforced by the Handle or Declare Rule, you need to extend the Exception class.</p></li>
<li><p>If you want to write a runtime exception, you need to extend the RuntimeException class.</p></li>
</ul>
<p>We can define our own Exception class as below &minus;</p>
<pre class="result notranslate">
class MyException extends Exception {
}
</pre>
<p>You just need to extend the predefined <b>Exception</b> class to create your own Exception. These are considered to be checked exceptions. The following <b>InsufficientFundsException</b> class is a user-defined exception that extends the Exception class, making it a checked exception. An exception class is like any other class, containing useful fields and methods.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate" id="exception">
// File Name InsufficientFundsException.java
import java.io.*;

public class InsufficientFundsException extends Exception {
   private double amount;
   
   public InsufficientFundsException(double amount) {
      this.amount = amount;
   }
   
   public double getAmount() {
      return amount;
   }
}
</pre>
<p>To demonstrate using our user-defined exception, the following CheckingAccount class contains a withdraw() method that throws an InsufficientFundsException.</p>
<pre class="prettyprint notranslate">
// File Name CheckingAccount.java
import java.io.*;

public class CheckingAccount {
   private double balance;
   private int number;
   
   public CheckingAccount(int number) {
      this.number = number;
   }
   
   public void deposit(double amount) {
      balance += amount;
   }
   
   public void withdraw(double amount) throws InsufficientFundsException {
      if(amount &lt;= balance) {
         balance -= amount;
      }else {
         double needs = amount - balance;
         throw new InsufficientFundsException(needs);
      }
   }
   
   public double getBalance() {
      return balance;
   }
   
   public int getNumber() {
      return number;
   }
}
</pre>
<p>The following BankDemo program demonstrates invoking the deposit() and withdraw() methods of CheckingAccount.</p>
<pre class="prettyprint notranslate">
// File Name BankDemo.java
public class BankDemo {

   public static void main(String [] args) {
      CheckingAccount c = new CheckingAccount(101);
      System.out.println("Depositing $500...");
      c.deposit(500.00);
      
      try {
         System.out.println("\nWithdrawing $100...");
         c.withdraw(100.00);
         System.out.println("\nWithdrawing $600...");
         c.withdraw(600.00);
      } catch (InsufficientFundsException e) {
         System.out.println("Sorry, but you are short $" + e.getAmount());
         e.printStackTrace();
      }
   }
}
</pre>
<p>Compile all the above three files and run BankDemo. This will produce the following result &minus;</p>
<h3>Output</h3>
<pre class="result notranslate">
Depositing $500...

Withdrawing $100...

Withdrawing $600...
Sorry, but you are short $200.0
InsufficientFundsException
         at CheckingAccount.withdraw(CheckingAccount.java:25)
         at BankDemo.main(BankDemo.java:13)
</pre>
<h2>Common Exceptions</h2>
<p>In Java, it is possible to define two catergories of Exceptions and Errors.</p>
<ul class="list">
<li><p><b>JVM Exceptions</b> &minus; These are exceptions/errors that are exclusively or logically thrown by the JVM. Examples: NullPointerException, ArrayIndexOutOfBoundsException, ClassCastException.</p></li>
<li><p><b>Programmatic Exceptions</b> &minus; These exceptions are thrown explicitly by the application or the API programmers. Examples: IllegalArgumentException, IllegalStateException.</p></li>
</ul>
</body>
</html>